#include <string>
using namespace std;
#ifndef Point
#define Point

class Point {
    public:
    Point();
    // 静态成员Static members———————————————————————————————————————————————————————————————
    // 静态成员是一种特殊类成员，它不是一个对象，而是一个类的成员，它有以下特性：
    // 不绑定到类示例：静态成员不属于任何特定的对象实例，它属于整个类
    // 共享内存：所有该类对象共享同一个静态数据成员
    // 生命周期：静态数据成员的生命周期和程序运行期间一直，它不会与对象的销毁和创建相关联
    
    // 静态成员的访问方式：
    // 类名::标识符
    // 比如：
    static int how_many;
    // 那么在驱动代码中可以创建代码：
    // Point::how_many = 0;
    // Point::how_many++;
    // 或者在类定义代码中编写用于调用或更改它的函数，通过调用函数来使用静态成员
    // 这就可以做到在驱动代码中记录有多少个Point类对象，每增加一个对象调用一次，且这个成员能保持作为Point类的成员
    // 这样，就能避免和驱动代码中的其他对象的命名存在冲突

    // 静态成员函数Static member functions————————————————————————————————————————————————————
    // 静态成员函数类似于静态成员，静态成员函数也不与该类的任何对象绑定，它也不能用于访问(或修改)任何
    // 该类的指定成员的私有数据成员
    // 静态成员函数可以访问：
    //      另一个静态成员函数
    //      该类的静态成员(其他类的不行)
    //      当前类以外的全局函数或数据

    // 静态成员函数 在类声明中应该以
    // static 类型 函数名()；
    // 声明，这和const类函数不一样，后者的const会放在函数后面而不是前面，比如：
    static int add_num();
    // 静态成员函数虽然在类声明处需要明确表明static，但在定义中不需要再表明为Static，比如：
    // int Point::add_num(){...}

    // 静态成员可以在不存在该类对象的情况下就直接在调用，比如：
    static int print_num(){
        cout << how_many << endl;
    }
    // 那么在驱动代码中可直接使用 Point::print_num() 调用该静态函数，哪怕没有带上任何该类对象
 
    // 静态成员函数中不存在 this指针，因为它不与任何该类对象关联，比如
    static int change_num(){
        how_many = 10; // 正确，因为静态成员函数不与任何对象绑定，但可以用于修改该类的静态成员
        // this->point_num = 10;  错误，因为不能使用this，因为它不绑定任何该类对象，自然无法修改
        // 某一个特定对象的私有数据成员
    }
    


    private:
    int point_num;
    string point_name;

};
#endif  /* Point_H*/


