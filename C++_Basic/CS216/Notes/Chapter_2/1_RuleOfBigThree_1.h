#include <string>
using namespace std;
#ifndef intList
#define intList

/*
Rule of Big Three 三大规则
三大规则代表，如果自定义的类中由动态分配的资源(比如new创建的对象)，那么需要
注意以下三个特殊函数的实现：

1：拷贝构造函数Copy constructor - 当创建一个对象作为另一个对象的副本时使用
2：赋值运算符Assignment operator - 当一个已存在的对象被赋值给另一个已存在
    的对象时使用
3：析构函数Destructor - 当对象被销毁时使用

规则的核心思想是：如果需要自定义其中任何一个函数，那么很可能需要定义全部三个
函数，否则可能出现内存泄漏或者其他问题
*/

class intList {
    public:
        intList();
        intList(int size, int capacity);
// 拷贝构造函数————————————————————————————————————————————————————————————
        // 比如这就是个拷贝构造函数，它用于初始化一个与other对象相同的值的新对象
        intList(const intList& other);

        // 并且它使用的是引用传递，而不是按值传递，这是因为按值传递会需要先复制
        // 一份源对象，而复制源对象的这个行为又需要使用拷贝构造函数，导致函数不停
        // 地调用自己，无限复制引发崩溃，比如：
        // intList(const intList other);
        // 按值传递的原理是复制一份源对象，将这个副本赋给目标，当实际代码中使用
        // 使用这个函数时，传入的参数会被复制成一份副本，然后副本通过 other 赋给
        // 目标对象，但是传入的参数被复制成副本的行为本身也需要使用拷贝构造函数
        // 导致函数开始呼叫自身，无限循环

        // 而正确的方式是使用 按引用传递&，这保证了函数不通过复制对象实现，而是直接
        // 访问源对象的值

        // 深拷贝和浅拷贝Deep/Shallow copy——————————————————————————————————
        /*
        当驱动代码中复制一个对象的值时，比如 intList obj2 = obj1；或者 obj2 = obj1；
        对象内部的 指针 或 引用 等动态分配内存时，不同拷贝方法有不同处理方式：

        浅拷贝 - 仅仅复制对象本身的成员变量的值，比如intList类的对象可能有成员对象 、
        int* list (private类里声明的成员变量)
        那么浅拷贝只是复制这个指针的地址值，而不是指针指向的实际数据
        浅拷贝进行的时成员级别的简单复制，复制后新对象和旧对象的指针成员指向的是
        同一个内存地址，虽然对象是两个，但成员的值却是同一块内存

        深拷贝 - 深拷贝是常理上的拷贝行为，它不是复制成员变量的地址，而是为指针成员
        指向的数据分配新的空间，数据会被复制在新的空间中，在复制以后，新的成员变量
        和旧的成员变量之间不再共用同一个内存地址上的变量

        浅拷贝 通常会带来问题，比如修改源对象的数据成员时，因为新对象也在用同一内存，
        导致新对象的数据也被修改
        或者，如果源对象释放了指针指向的内存，那么新对象的指针就会指向无效内存，或者
        因为代码导致重复释放内存

        因此，通常来说应该自行定义拷贝构造函数来进行深拷贝，
        因为系统提供的默认拷贝构造函数使用的是 浅拷贝，如果没有自行定义拷贝构造函数
        (代码里直接没有)，那么编译器会提供一个浅拷贝形式的拷贝函数
        如果类里没有动态分配的资源，没有裸指针，只有int string之类的，那么系统的
        浅拷贝函数是安全可使用的，但如果有这类成员，那么必须自行构造深拷贝函数
        */

        /*
        错误的浅拷贝代码：
        size = other.size;
        capacity = other.capacity;
        list = other.list;
        之所以错误，是因为这里的list是个指针，而不是变量，它指向的才是实际的值，如果直接写
        list = other.list，那么新对象的list和旧对象的list都是指向同一地址的指针

        正确的深拷贝代码：
        size = other.size;
        capacity = other.capacity;
        for (int i=0; i < size; i++){
            list[i] = other.list[i];
        }
        通过一个for循环直接访问进数组，并逐个将数组内的元素进行复制，而不是直接复制
        指向数组的地址
        */




    private:
        int size;
        int capacity;
        int* list;

}
#endif  /* intList_H*/
