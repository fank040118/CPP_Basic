#include <iostream>
#include <string>

using namespace std;

int main(){

    // 邻接映射——————————————————————————————————————————————————————————————————————————————
    // 邻接映射实际上可以使用一种更加直观的方式，就是使用已经学过的Map
    // Map的每一对键值对应<顶点，直接连接到该顶点的其他顶点集合>
    // 也就是说，Key 代表 当前顶点，Value 代表 连接当前 Key 的其他顶点
    // 它和邻接表的结构几乎一样，也是 顶点 - 链接顶点集合 的形式，但作为单一的变量，更易于管理
    //
    // 广度优先搜索Breadth-First Search，BFS算法—————————————————————————————————————————————
    // 广度优先搜索是一种特殊算法，用于遍历或搜索数或图结构
    // 算法从根节点(对于图，任意一个节点都是起始点)开始，并先完整探索当前深度层的所有相邻节点
    // 然后再移动到下一层，这类似于一个水波纹，先经过中心点附近，再往外扩散
    // 这种算法使得BFS非常适合寻找最短路径，或者寻找迷宫的解
    // BFS通常使用队列数据结构，以确保先进先出，这样就能让先进入的临近节点先被处理，最后处理最远的
    //
    // 广度优先搜索的执行规则有三条：
    // 1：访问当前顶点相邻的下一个未访问过的顶点(若存在)，标记该顶点为已访问，并插入进队列中
    // 2：如果无法执行规则1(因为没有更多未访问的相邻节点)，那么从队列中取出一个顶点(若队列未空)，
    //    并将其设为新的起始点
    // 3：若无法执行规则2，那就代表没有未探测过的顶点了，算法结束
    //
    // 例如，一个BFS的伪代码逻辑如下：
    // 1：初始化阶段————————————————————————
    //    将所有顶点的 访问状态 先设置为false
    //    创建一个 空队列Q
    //    将 起始顶点Source 标记为已访问
    //    设置起始顶点的 距离 为0
    //    将起始顶点自身弹入队列
    // 2：主循环阶段————————————————————————
    //    当队列不为空时，循环保持继续：
    //    从队列中取出队首顶点u(第一次是起始顶点)：
    //    对于与u相邻的每个顶点w：
    //        若w未被访问过：
    //           将其标记为 已访问过
    //           设置w的距离为u的距离+1
    //           将w加入队列
    //
    //    这样代码将会不断朝起始顶点以外的相邻点衍伸，直到队列未空，这代表所有顶点都被遍历过了

    return 0;
}

















