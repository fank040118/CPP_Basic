#include <iostream>
#include <string>
using namespace std;

string* to_cpp_string(char *);

int main(){

    // 当创建普通的使用动态内存的变量时，每个变量之间的内存地址并不一定是连续的
    // 比如在使用int ... = new string(...)创建一个变量后立即创建另一个同类
    // 的变量，它们也并不一定在内存上紧挨在一起，

    // new[]运算符————————————————————————

    // new[] 是 new运算符 的衍生运算符，它用于创建一个指定类型的数组
    // new[]运算符 和 new 并不一样，它所创建的数组和传统数组一样，其内存位置
    // 是紧挨在一起的，所以它所创建的数组也和传统数组一样，可以通过索引访问
    // 特定位置上的值（数组名=数组首元素的地址，索引=地址的偏移量）
    int *p, num = 5;
    // 可以通过 new 类型[大小] 来创建一个指定大小的动态数组，这样创建出来的数组
    // 能够储存多个该类型的值，但在创建时，它默认会是0值
    p = new int[num];
    // 由于 指针p 指向了这个动态数组，那么它实际上也能被看作为这个动态数组的变量名
    // 我们知道数组的变量名实际上就是数组首元素的地址，这和p的值是等价的
    for(int i = 0; i < num ; i++){
        p[i] = i; // 那么可以直接使用索引访问方式去调用数组的特定值
    }
    for (int i = 0; i < num; i++){
        cout << p[i];
    }
    cout << endl;

    int *p2;
    // 从 C++11 开始，也可以直接对动态数组一次性赋值，语法类似于传统数组的赋值方法
    p2 = new int[10]{0,1,2,3,4};
    for (int i = 0; i < 10; i++){
        cout << p2[i];
    }
    cout << endl;
    
    // delete运算符————————————————————————

    int *p3 = new int(5);
    cout << *p3 << endl;
    // 动态内存中的对象不会自动删除，如果不手动使用 delete运算符 删除对象的话，它会在
    // 创建后到程序结束期间一直存在，如果程序周期长，或者变量数量多，那么这会导致程序
    // 产生内存泄漏，即不再需要的变量不占用内存而没有被回收 delete运算符 的语法为：
    // delete 指针
    // 由于动态内存中的变量没有变量名，唯一访问这些变量的方式是使用指向其内存地址的指针
    // 所以删除这些变量的值时也需要依赖指向它的指针，如果指针消失，那么也将失去访问该
    // 变量的路径，这代表不仅无法修改，调用变量，也无法删除变量
    delete p3;
    // 运行 delete运算符 后，其指向的值就已经被删除了，但是指针本身仍然存在，且指针
    // 指向的地址可能会被放置为其它内容，所以保险起见，需要在删除后立即将指针设置为空指针
    p3 = nullptr;

    // delete[]运算符———————————————————————
    
    // 当使用 new[]运算符 创建了一个使用了一串连续内存地址的动态数组，就需要使用delete[]
    // 来删除整段数组的内存中的数据，而不是使用 delete运算符，因为它被设计用于删除单个对象
    // 的值，如果强行使用 delete 删除一个动态数组，那么可能会导致未定义的行为
    delete[] p;



    // 那么就可以使用动态变量来解决之前由于栈导致的问题
    char init_greeting[] = "Hello, World!";
    string* cpp_version = nullptr;
    cpp_version = to_cpp_string(init_greeting);
    cout << *cpp_version << endl;
    delete cpp_version;   // 手动释放堆上分配的string
    cpp_version = nullptr; 

    return 0;
}
string* to_cpp_string(char *c_str) { // 传入C字符串的地址(不是地址的话会只有第一个字符)
    string* cpp_str_ptr = new string(c_str);  // 在堆上创建一个string对象，这样就不用
    // 担心对象在函数结束后随栈回收
    return cpp_str_ptr;                       // 返回堆上对象的指针
}
