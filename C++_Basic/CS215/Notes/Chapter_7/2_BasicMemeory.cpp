#include <iostream>
#include <string>

using namespace std;

/*
内存有两种行为，分配(Allocate)和释放(Deallocate)，
分配是指为某一种用途预留一部分内存，比如一个变量
释放是指程序不再需要某一部分内存时将其归还给系统

内存有着几种不同的类型：
静态内存(Static Memory)：
	在程序运行以前就被分配好的内存，并且在程序的整个生命周期内都存在，不会归还系统
	比如 全局变量，静态变量 等

自动内存/栈内存(Automatic Memory/Stack Memory)：
	在程序执行时自动分配和释放，是默认的内存管理方式
	比如 函数中的局部变量

动态内存/堆内存(Dynamic Memory/Heap Memory)
	在运行时通过显式调用(new 或 malloc),需要显式释放(delete 或 free)
	充满灵活性，但很容易引发内存泄漏或悬空指针

静态内存在程序开始时分配，结束时释放
自动内存在作用域内分配，作用域结束时释放
动态内存由程序员决定分配和释放

静态内存和自动内存都由编译器管理，动态内存由程序员显式管理，
静态内存位于数据区(Data Segement)，
自动内存位于栈(Stack)，
动态内存位于堆(Heap)
*/

void  staticFunc() {
	static int callCount = 0; // 创建一个静态变量，静态变量只会初始化一次
	// 静态变量的作用域(Scope)和普通函数一样只存在于被定义时所处于的函数区，
	// 但是它被储存在静态内存中，所以即使函数的内存被释放，它也保留
	callCount += 1; // 静态变量每次运行函数时都会 +1
	cout << callCount << endl; // 输出静态变量的值
}

string* to_cpp_string(char* c_str) { 
	// 传入的是 char类对象的地址，而不是char类对象本身，因为创建时使用的
	// char init_greeting[] = "Hello, World!"; 
	// 创建的是一个char类数组，我们知道，数组的变量名实际上就是一个指向
	// 数组头元素的地址，所以当我们使用to_cpp_string(init_greeting);
	// 传入一个char类数组给函数时，实际上传入的是这个char类数组的地址
	// 这就是为什么传入时并不需要加上 地址操作符& 也能让参数获取到这个变量
	// 的地址

	string cpp_str(c_str); // 将传入的 char类指针指向的值赋值给string变量，
	// 这是一种特殊的赋值方法，可以将char类数组的值赋给string类对象
	return &cpp_str; // 最终返回构造的string类对象的地址
}

int main() {
	

	// 静态内存：—————————————————————————————————

	staticFunc(); // 第一次呼叫函数，callCount = 1
	staticFunc(); // 第二次， callCount = 2
	staticFunc(); // 第三次， callCount = 3

	// 这是因为函数内使用的是 静态变量(Static veriable)，静态变量被储存在了
	// 数据段(Data Segment)上，而不是栈上，所以在函数结束以后，它的值仍然保留，
	// 静态变量在函数调用期间会保留其状态(即上一次调用时的值)，静态变量使用的
	// 就是 静态内存，它被放在数据段(Data segment)中，在main()函数开始之前就
	// 被分配，在main()函数结束以后才会释放

	// 数据段(Data Segment)是内存的一部分，它专门用于储存静态分配的变量，包括全局变量
	// 和静态变量，数据段分为两部分：
	// 可写部分——储存可修改的全局变量和静态变量，这些变量在程序中途可以修改
	// 只读部分——储存只读的数据，比如用 const 修饰的全局常量，这些数据在中途不可修改
	// 静态变量的内存在数据段中是固定的，在程序生命周期内一直都在，它不能被删除
	// 静态变量的内存分配在程序启动时就会被分配，但是静态变量的初始化会在相应代码运行时进行


	// 自动内存：—————————————————————————————————

	char init_greeting[] = "Hello, World!"; // 创建一个char类数组，储存了一系列字符
	string* cpp_version = nullptr; //创建并初始化一个指针
	cpp_version = to_cpp_string(init_greeting); // 将char类数组经过函数后的返回值赋值给指针

	// cout << *cpp_version << endl; 
	// 这将导致错误，因为cpp_version指向的对象是一个局部变量，创建于呼叫的函数的定义域内
	// 局部变量使用了自动内存，在函数结束后将会被回收，导致地址指向的值变为无效
	// 自动内存使用的则是之前介绍的 栈(Stack)，与数据段(Data segment)不同，栈储存的是局部变量
	// 和函数调用信息的内存区域，栈上的内存由程序自动管理，	其生命周期被限制为了函数执行期间
	// 当函数返回时，栈上的内存就被清除，所以 cpp_version 这个地址指向的原变量 cpp_str
	// 在 return 执行后就已经消失

	
	// 动态内存：—————————————————————————————————

	// 有时候我们希望能够自行控制一个变量的生命周期，什么时候被创建，什么时候被清除等
	// 比如希望创建一个变量，既不希望它在程序结束时才被清楚，也不希望它在函数结束时就被清除
	// 那么就需要使用到动态内存

	// 程序员需要时可以通过 new运算符 来从 堆 上申请内存，与自动内存不同的是，这个内存不依赖
	// 函数调用，它可以随时进行，无论是函数内还是函数外
	// 动态内存需要在不被需要时可以用 delete运算符 手动回收，动态内存需要程序员自行掌控
	// 时机回收，避免产生内存溢出
	// 动态内存都来自于 堆(Heap) 而不是自动内存所使用的 栈(Stack)，也不是静态内存所使用
	// 的 数据区(Data segment)
	
	string *p = new string("ABCDE");
	// 通过 “new 类型(值)” 来创建一个储存于 堆 的动态内存的变量，要注意的是，通常来说
	// 动态内存上的变量 没有变量名，就如同上面的代码一样，用于访问它的方法是创建一个
	// 执行它的地址的 指针，如果这里直接使用
	// new string("ABCED"); 
	// 创建变量(不包含指针)，那么在它被创建出来以后，将没有任何方法再去找到这个变量
	// 因为无法使用变量名访问它，也没有指向它的指针

	// new运算符 本身就会返回一个指针，它的作用是在 堆 上创建一个动态对象，并返回该
	// 对象的指针，所以这里写的是 string *p = new string 而不是 string *p = new &string
	// 因为 new运算符 已经包含了地址的返回过程，不再需要使用 地址操作符&

	p->append("FG"); // 通过箭头指示符为这个变量添加字符
	cout << *p << endl; // 打印指针指向的变量的值
	// 在上面的代码中，等号左边的 p 是一个指针变量，它创建时并未使用 new运算符，所以实际上
	// 仍然是一个 局部变量，它仍然储存在栈上，但等号后面的 new string 分配的 string类型
	// 的实际字符串则储存在 堆(Heap) 上，因为它使用的是 new运算符

	// 这里的一个重点是，堆上的内存不会自动清除，它一直存在，直到存在用于清除它的代码运行
	// 这里被创建的 new string对象 会一直保持在 堆 上，不会因为函数结束而被清除，如果创建
	// 它的代码位于其它函数，那么即使函数返回了，这个变量也仍然存在
	// 在此处，即使main函数结束了，变量也仍然存在(只是举例，通常来说main函数结束后它也不会
	// 有什么作用)，所以储存在 堆 上的变量可以通过指针在不同函数之间不停传输，而不用担心
	// 函数结束而消失，但动态内存上的数据在程序结束时也会被清除，这是程序本身的规则

	string *p2 = p;
	p2->append("HIJKLMN");
	// 可以创建另一个栈上的string类地址，将其地址设置为p的地址，这样它也可以用于更改
	// 动态内存上的变量的值
	cout << *p2 << endl;
	






	return 0;
}