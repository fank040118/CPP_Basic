#include <iostream>
#include <string>
#include <vector>

using namespace std;

// 递归(Resursion)———————————————————————————————————————————————

// 递归(Recursion) 是一种强大的问题求解技巧，它将复杂问题分解为更简单的同类问题
// 的其它版本来解决
// 递归通常通过让函数调用自己来实现，当函数调用的逻辑重复出现时，这和迭代器的概念
// 不同，递归更像是将问题分解和缩小，逐步处理一个庞大的问题

// 比如想要打印一个三角形
// *
// **
// ***
// ****
// 传统的方式是使用一个嵌套循环来解决，但是如果使用递归思维来看的话：
// 要打印一个大小为4的三角形，实际上可以先假设有一个函数能打印大小为3的三角形
// 然后在函数完成以后再打印一行4个星号
// 同理，一个大小为5的三角形也可以看作先打印大小为4的三角形后再打印一行5个星号

// 这种思维方式就是递归：当程序能够解决规模更小的子问题时，只需要增加一点点工作
// 就能解决更大规模的问题


// 递归函数(Resursion)————————————————————————————————————————————

// 递归函数是递归的最常用示例，比如有一个函数如下：
void printNum(int num){
    if(num == 0){return;} // 暂时无视这一行
    printNum(num-1); // 呼叫自身并传入一个更小的数字
    cout << num << endl; // 如果上面的呼叫的函数执行完了，那么打印当前数字
}
// 在这个递归函数中，如果用户传入了数字 5，那么其执行如下：
/*
printNum(5):
    printNum(4):
        printNum(3):
            printNum(2):
                printNum(1):
                    printNum(0):
*/
// 每个函数都会呼叫自己一遍，并且传入的参数依次减小，
// printNum(5)会呼叫printNum(4)，而printNum(4)又会呼叫printNum(3)...
// 在递归函数中，只有在下一层函数执行完毕并返回后，上一层函数才会开始执行，因为每个
// printNum(num-1); 都在 cout << num << endl; 前面，所以只有下一层函数回退，
// 才轮到 cout 命令开始执行
// 也就是说这里只有在 printNum(0) 执行完毕以后，printNum(1) 才会执行，依次类推
// 那么最终所打印的值的顺序将会和函数的呼叫顺序相反，为12345而不是54321
// 这和栈的概念比较类似，printNum(5)被先呼叫，所以最晚执行，printNum(0)被最晚呼叫
// 所以最先执行


// 基例(Base case)————————————————————————————————————————————————

// 一个递归函数必须有一个 基例，基例 的意思是一个问题的 最小/最大规模，如果没有最小或者
// 最大值，那么这个递归函数就会不断运行，比如在刚才的例子中，当printNum()传入的数字为
// 0时，函数就会触发 if(num == 0){return;}，导致printNum(0)直接退出，而不再继续递归
// 为什么要这样呢？因为不存在这个语句的话，函数就会开始呼叫 -1，-2，-3，-4...
// 永不停止，导致所有函数都不会执行，所以为了避免这种无限的递归调用，一个递归函数必须
// 存在一个 “最小的情况” 和 “最大的情况”

// 那么在刚才的例子中，基例就是 0，当传入的参数为 0 时，将其工作流程更改为直接退出函数
// 而不是继续呼叫函数，这样无论最初呼叫的值多大，只要其减小到0都会开始打印数字


// 更复杂的递归—————————————————————————————————————————————————————

// 比如这里的函数就是一个递归函数，此处的side_len就是用户想要打印的三角形的长度
// 只要用户在main中呼叫了这个函数，函数就会再次呼叫自己，但传入的大小是原长度-1
// 比如用户呼叫函数print(4)，
// 而这个函数又会呼叫print(3)，
// 而这个函数又会呼叫print(2)，
// 而这个函数又会呼叫print(1)，
// 最终，呼叫到print(0)，
void print_triangle(int side_len){
    // 为递归函数设置一个基例
    if(side_len == 0){return;}
    // 呼叫自身并传入一个更小的数字
    print_triangle(side_len-1);
    // 如果上面呼叫的函数结束了，那么打印当前一行的星号
    for(int i = 0; i < side_len; i++){
        cout << "* ";
    }
    cout << endl;
}

// 限制范围————————————————————————————————————————————————————————

// 在上面说到了 基例 是一个递归函数 最小 或者 最大 的情况，用于结束递归传递链
// 但是除了基例以外，还需要限制参数的范围，比如刚才从大到小打印数字的递归函数来说
// 如果用户一开始传入的参数是一个 负数，那么递归函数就会永远进行下去并永远不会打印数字
// 因为这个数字不断减小也还是负数，它永远不会等于0，那么递归传递链永远都不会结束
// 所以为了避免这种错误的递归出现，必须在传入参数时就先限制参数的传入范围必须大于等于0
// 或者在刚才的例子中，可以直接将 == 0 更改为 <= 0，那么负数时将会直接退出函数

// 回文检测————————————————————————————————————————————————————————————
// 回文Palindrome 是一种头尾字符都一样的句子
// 比如 star rats 是一个回文，头字符和尾字符一样，第二字符和倒数第二字符一样，以此类推
// 一个字符串的长度为 0 或者 1 的话，那它就一定是回文，因为找不到不一样的字符
// 那么为了检测一个字符串是否是回文，就可以通过 递归 的方法分别从前和从后检查字符
// 并将 基例 设置为字符串长度为 0 或 1 的情况，因为那种情况下必定是回文

bool is_palindrome (const string& input){
    const int stringLength = input.size();
    if(stringLength <= 1){
        return true;
    }

    else if(input[0] == input[input.size()-1]){
        const string nextString = input.substr(1,input.length()-2);
        return(is_palindrome(nextString));
    }

    else{return false;}
}

int main(){
    
    int userNum = 5;
    printNum(userNum);

    int userNum2 = 4;
    print_triangle(userNum2);



    return 0;
}