#include <iostream>
#include <string>

// 链表(Linked List)——————————————————————————————————————————————————
// 链表Linked List是一种动态的线性数据结构，它和数组一样可以储存多个元素，但数组
// 使用的是固定大小的内存，如果元素超过或少于数组的大小，就会导致溢出或者浪费空间
// 而链表却有着动态的大小

// 节点(Node)—————————————————————————————————————————————————————————
// 链表的基本单位叫做 节点(Node)，它是通过动态内存分配创建出来的对象
// 一个节点包含两个成员：Key(或Data) 与 Next
// Key是用来储存该单位节点内的元素的，而Next是一个指向下一个节点的指针
// 一个节点的通常储存样式是 [数据][指针]
// 比如 数据储存在了 内存地址=2135 处， 指针储存在了 内存地址=2136 处

// 为什么需要有指向下一个节点呢？
// 因为链表的每个节点所在的位置可能在内存上是不相邻的，毕竟它的大小是动态的，
// 可能在代码运行途中添加新的元素，而添加新元素时上一个元素的下一个内存位置可能
// 已经被其它变量占用了，所以链表的内存位置并不连续
// 那么想要访问下一个数据，就只能靠地址来访问，而无法像数列一样使用索引访问
// 因为索引是地址的偏移量，而链表一个元素的地址偏移一位不一定是下一个元素

// 如果一个链表储存了5个元素，那么就相当于在内存内创建了5个节点，每个节点储存了
// 一个元素，以及一个指向下一个节点的指针

// 头指针(pHead)———————————————————————————————————————————————————————
// 一个链表除了储存数据的节点以外，还有一个特殊的指针pHead，它用于指向链表
// 的第一个节点，也就是说链表的开头并不是第一个数据，而是一个指向第一个数据的指针
// 如果第一个数据是空的，那么 pHead = Null
// 除此以外，最后一个节点的Next也是Null，因为没有下一个节点了

// 通常访问链表都只能从头指针开始，因为变量名本身储存的就是头指针，而其它节点
// 则要依靠头指针储存的地址

// 单向链表(singly linked list)————————————————————————————————————————
// 单向链表是链表的一种，它和之前提到的知识点相符，链表有一个头指针，和一系列节点
// 每个节点都有一个 数据位(key) 和一个 指针位(Next)，指针指向下一个值
// 但这也引出了一个问题：每个节点都没有指向上一个节点的地址，那么也就无法回过头访问
// 上一个节点的数据，所以单向链表的访问方式是只能从 头指针 一路访问，直到遇到Null为止

// 单项列表只能从 头指针 一直线性访问每个节点，如果想要访问前一个节点，那就需要从头重新
// 开始访问链表直到那个位置

// 双向链表(double linked list)————————————————————————————————————————
// 双向链表解决了单向链表无法往回访问的问题，在双向链表中，链表不仅有一个头指针
// 还在尾部有一个 尾指针(tail，pTail)，并且双向链表中每个节点都额外储存了一个指向
// 上一个元素的指针(Prev)，所以在双向链表中，可以从尾部向前访问，也可以从头部向后访问

#include <list>

using namespace std;

int main(){

    // 通过 list<类型> 链表名 创建一个链表
    list<string> names;
    // 链表可以使用push_front()和push_back()两种函数，分别可以在链表的头部和尾部
    // 新增元素
    names.push_back("Tom");
    names.push_back("David");
    names.push_back("Harry");

    // 通过 front() 或 back() 可以返回第一个元素或最后一个元素
    cout << names.front() << endl;
    
    // 在没有使用其它方法的情况下，访问第二个元素的方法有些复杂，可以将第一个元素
    // 复制到尾部，然后再将第一个元素弹掉，那么此时第一个元素就变成了原来的第二个元素
    // 而原来的第一个元素则变成了最后一个元素
    names.push_back(names.front());
    names.pop_front();
    // 最后再访问第一个元素，就能够得到第二个元素了
    cout << names.front() << endl;

    // 迭代器(Iterator)————————————————————————————————————
    // 迭代器是C++中为容器(如list，vector)提供的一种 类指针 对象，它可以用来在容器元素
    // 之间遍历，访问或者操作，迭代器表现形式和指针几乎一样，如同指针一样可以使用
    // *迭代器 来取值， 迭代器++ 来移动，但它本质上是对元素的引用，在多个元素之间
    // 移动，这是指针无法做到的，因为链表的地址不一定连续，指针无法得知下一个元素的地址
    // 而迭代器则可以根据容器类型自行找到上下元素的位置

    // 创建一个迭代器的方法是 容器类型<数据类型>::iterator 迭代器名；
    list<string>::iterator pos;
    // 在创建一个迭代器以后，它并没有指向任何容器的实际元素，所以需要靠
    // 迭代器名 = 容器.某个元素位置 来让迭代器指向一个实际的位置
    pos = names.begin();

    // 迭代器可以通过 ++ 或 -- 在容器中的多个元素之间移动
    pos++;
    // 通过 *迭代器名 像解引用地址一样获取到其指向的特定值
    // 此时链表是 [David Harry Tom]
    // 迭代器之前已经进行过 ++，所以现在指向的元素是 [Harry]
    cout << *pos << endl;

    pos++; // 此时迭代器指向元素[Tom]
    cout << *pos << endl;

    *pos = "Romeo"; // 通过解引用，修改第三个元素，那么此时
    // 链表就变成了 [David Harry Romeo]
    cout << names.back() << endl; // 通过 back() 返回最后一个元素

    // insert()——————————————————————————————————————————
    pos--; // 将迭代器指向 [Harry]
    
    // insert()是用来插入新元素的函数，它会在指向的位置的 前面 插入一个新元素
    // 使用方法是 链表名.insert(迭代器,元素)；

    // 链表本来是 [David Harry Romeo]，由于pos指向Harry，所以现在链表变成了
    // [David Anthony Harry Romeo]
    names.insert(pos,"Anthony");
    pos--;
    cout << *pos << endl;

    // end()——————————————————————————————————————————————
    // end()会返回 链表的末尾的往后一个位置 ，也就是说它指向的并不是链表的最后
    // 一个元素，而是链表的边界的外面，用来标记链表的终点，
    // 那么如果把迭代器设置到 end() 上，那么insert()函数才会把元素放置在
    // 一个链表的最后，因为insert()函数会在指向位置之前插入元素，如果把pos
    // 设成最后一个元素的话，那么它就会被插到倒数第二的位置，而不是末尾
    pos = names.end();
    names.insert(pos,"Juliet"); // 此时链表为[David Anthony Harry Romeo Juliet]
    pos--;
    cout << *pos << endl;
    // end() 返回的实际上也是一个迭代器对象，因为它指向的位置是链表的最后一个元素
    // 的更往后一位，所以它实际上只是作为一个边界标记，没有实际元素
    // 如果尝试修改它本身，或者尝试解引用它，比如呼叫它，那么会导致编译器出错

    // erase()———————————————————————————————————————————
    // erase() 用于删除链表中的元素，且它会 返回删除元素之后的下一个元素 的迭代器
    pos = names.begin(); // 重新将迭代器设为初始元素，即 [David]
    pos++; // 迭代器此时为[Anthony]
    pos = names.erase(pos); // [Anthony] 遭到删除，所以链表此时为
    // [David Harry Romer Juliet]，且由于erase()返回了[Anthony]的下一个元素
    // 所以pos此时指向了[Harry]
    cout << *pos << endl;

    // 遍历链表———————————————————————————————————————————
    cout << "----------" << endl;
    // 由于链表需要使用迭代器来寻找元素，所以可以使用一个for循环
    // 并不断 增加/减少 迭代器的值，以循环整个链表
    for(pos = names.begin(); pos != names.end(); pos++){
        cout << *pos << endl;
        cout << "----------" << endl;
    }


    return 0;
}