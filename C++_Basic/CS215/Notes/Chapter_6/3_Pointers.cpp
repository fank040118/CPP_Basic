#include <iostream>
#include <iomanip>
#include <string>

using namespace std;

int main(){
    /*
    指针(Pointer)是用于储存内存中其他变量地址的特殊变量假设内存中
    有许多储存单元，每个储存单元有8位宽，即8bit，也为1字节(1 Byte)
    每个储存单元都存有实际的二进制数据，作为实际对象的数据
    那么每个储存单元都有自己独自的内存地址，如(0x00007FFF8E3...)。
    内存地址与储存单元相对应，直接指向其储存的数据

    那么指针(Pointer)就是一个储存数据对象在内存中地址的变量

    指针有许多用处，比如指针可以用来传递函数参数和返回值，使得传递
    变得类似于 引用传递Call by reference
    同时，由于指针直接访问变量的内存地址，所以它可以无视部分C++的
    规则和限制
    */

    // 创建指针————————————————————————————————————————————————————
    // 在C++中，指针的创建语法为 类型* 变量名，也就是说，指针和普通
    // 变量创建的最大区别是它需要在类型声明后加上 *
    // 指针虽然是储存对象的内存地址的变量，但指针所指向的变量却是存在
    // 类型的，所以指针在创建时也需要包含类型，int* 指向int变量
    int  *ip;
    float *fp;
    
    // 若创建时同时声明了多个变量，那么不加上 * 的变量都不会是指针
    // 比如此处的 ip3 并未加上 *，所以它只是一个普通的int变量
    int *ip2, ip3, *ip4;

    int userNum_1 = 55;
    // 地址操作符 & 用于获取变量的内存地址，此处将userNum_1的内存地址
    // 赋给指针ip，此时，ip的值就是userNum_1的地址，但这不代表ip与
    // 其相关联，这更类似于 按值引用 ，ip的值是userNum_1的内存地址
    // 但它只是储存了其内存地址，并不与变量绑定，如果修改ip的值，也不会
    // 让userNum_1的内存地址发生变化
    ip = & userNum_1; // 将userNum_1的内存赋给变量ip
    cout << ip << endl; // 输出ip，它会是一个内存地址

    // 解引用——————————————————————————————————————————————————————
    // 解引用操作符 * 用于访问指针指向的变量，* 在创建变量时用于声明变量
    // 为指针，但如果用在一个已经是指针的变量上，那么它就会变成逆向访问
    // 指针所储存的地址的变量，比如在上面ip的值已经被赋予了userNum_1的变量
    // 那么这里使用 *ip 将会访问ip储存的地址的变量，这个过程叫 解引用
    cout << *ip << endl; // 输出ip的解引用，即指针指向的变量的值

    // 虽然指针只是储存了一个变量的地址，而没有与变量绑定，并不是成为了
    // 变量的地址，但是如果变量的值发生了变化，也还会是在同一地址上
    // 比如这里userNum_1从55变为了60，但是它的内存地址并没有变化，
    // 所以当我们再次使用 *ip 去解引用获取地址上的变量时，它也可以获取
    // 新的userNum_1的值，即60
    userNum_1 = 60;
    cout << *ip << endl;

    // 利用解引用修改变量————————————————————————————————————————————
    int userNum_2 = 65;
    // 在这个例子中 ip 得到了userNum_1的地址，ip2得到了userNum_2的地址
    ip = & userNum_1;
    ip2 = & userNum_2;
    // 那么解引用后，*ip的值就应该是60，*ip2的值就应该是65
    cout << ip << " " << ip2 << endl;
    cout << *ip << " " << *ip2 << endl;
    // 但是，我们已知解引用代表去获取指针指向的内存地址的储存的值
    // 也就是说，*ip2实际上调用的就是userNum_2的值，那么我们也可以
    // 使用解引用去直接修改userNum_2的值
    *ip2 = 70;
    // 可以看到修改后，ip2所指向的userNum_2的值变为了70
    // 虽然ip2并不与userNum_2绑定，但是解引用的它时访问的是指针指向的值
    // 也就是说 *ip = 70 实际上等价于 userNum_2 = 70
    cout << ip << " " << ip2 << endl;
    cout << *ip << " " << *ip2 << endl;

    // 进一步的例子来说，通过解引用去修改指针指向的变量的值，不仅可以
    // 直接更改变量的值，也可以解引用另一个指针，将另一个指针指向的
    // 变量的值赋给这个变量
    // 在下面的例子中，不仅可以直接依靠*ip4去修改userNum_3的值，
    // 还可以通过 *ip4 = *ip3 来将ip3指向的变量的值赋值给ip4指向的值
    int userNum_3 = 1;
    ip4 = &userNum_3;
    cout << userNum_3 << endl;
    *ip4 = 2;
    cout << userNum_3 << endl;
    *ip4 = *ip2;
    cout << userNum_3 << endl;

    // 同样的，也可以将一个指针所保存的地址赋予给另一个指针，使得改变
    // 另一个指针的解引用时也能改变目标地址的变量的值
    int *ip5;
    ip5 = &userNum_1;
    cout << userNum_1 << endl;
    ip4 = ip5;
    *ip5 = 33;
    cout << userNum_1 << endl; 

    return 0;
}